cahier des charges :
5 heuristique possible;
classique distance de manhattan.
pythagore
pythagore + linear colision
manhattan + linear colision
hamming distance

le programme doit afficher le nombre de node séléctionné dans la open list.

le maximum de node stocke en memoire dans la closed list et open list;

le nombre de movement executer par le programme pour resoudre le probleme

il doit egalement afficher le bon chemin (duh)

si le puzzle est insoluble, le programme est cense le reconnaitre et le dire.



todo:*

implémenter les différentes classes et instantier les différentes classes pour
faire des essais et vérifier qu'elles fonctionnent bien et son stables. // globalement CHECK

coder la fonction pour avoir la position de la case vide. CHECK
coder les mouvements du puzzle CHECK

créer un générateur de npuzzle qui mélange le npuzzle  CHECK

créer un ensemble de fonctions permettant l'affichage pratique du puzzle. CHECK 

implémenter la classe environnement qui va stocker la pool de puzzle, le scrambler ainsi que les instances des classes algorithmes. CHECK

implémenter l'algorithme de résolution. CHECK

optimisation possible :
- tenter la transformations des allocations dynamiques en allocations sur la pile. CHECK
- implémenter l'optimisation du parcours de l'open list comme vu dans le tuto de Unity. IMPOSSIBLE
- transformer la open list en HEAP (datastructures)

- MODIFIER LHEURISTIQUE pour implémenter les linear colision


modifier le main afin de faire la récupération d'argument de manière dynamique et de pouvoir récupérer un npuzzle
en argumet sous forme de fichier texte.


